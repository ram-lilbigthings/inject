"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blocksAddressesAll = exports.blocksAddresses = exports.blocksTxsAll = exports.blocksTxs = exports.blocksPrevious = exports.blocksNext = exports.blocksLatestTxsAll = exports.blocksLatestTxs = exports.blocksLatest = exports.blocks = void 0;
const utils_1 = require("../../../utils");
const errors_1 = require("../../../utils/errors");
/**
 * Obtains a specific block.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1latest/get | API docs for Latest block}
 *
 * @param hashOrNumber - Hash or number of the requested block
 * @returns Specific block
 *
 */
async function blocks(hashOrNumber) {
    try {
        const res = await this.instance(`blocks/${hashOrNumber}`);
        return res.body;
    }
    catch (error) {
        throw (0, errors_1.handleError)(error);
    }
}
exports.blocks = blocks;
/**
 * Obtains the specific block available to the backends, also known as the tip of the blockchain.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1latest/get | API docs for Latest block}
 *
 * @returns latest block
 *
 */
async function blocksLatest() {
    try {
        const res = await this.instance(`blocks/latest`);
        return res.body;
    }
    catch (error) {
        throw (0, errors_1.handleError)(error);
    }
}
exports.blocksLatest = blocksLatest;
/**
 * Obtains transactions within the latest block.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1latest~1txs/get | API docs for Latest block transactions}
 *
 * @param pagination - Optional, Pagination options
 * @returns transactions within the latest block
 *
 */
async function blocksLatestTxs(pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    try {
        const res = await this.instance(`blocks/latest/txs`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        });
        return res.body;
    }
    catch (error) {
        throw (0, errors_1.handleError)(error);
    }
}
exports.blocksLatestTxs = blocksLatestTxs;
/**
 * Obtains all transactions within the latest block.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1latest~1txs/get | API docs for Latest block transactions}
 * @remarks
 * Variant of `blocksLatestTxs` method for fetching all pages with built-in requests batching
 *
 * @param allMethodOptions - Optional, Options for request batching
 * @returns transactions within the latest block
 *
 */
async function blocksLatestTxsAll(allMethodOptions) {
    return (0, utils_1.paginateMethod)(pagination => this.blocksLatestTxs(pagination), allMethodOptions);
}
exports.blocksLatestTxsAll = blocksLatestTxsAll;
/**
 * Obtains list of blocks following a specific block.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1%7Bhash_or_number%7D~1next/get | API docs for Listing of next blocks}
 *
 * @param hashOrNumber - Hash or number of the requested block
 * @param pagination - Optional, Pagination options
 * @returns List of blocks following a specific block
 *
 */
async function blocksNext(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    try {
        const res = await this.instance(`blocks/${hashOrNumber}/next`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
            },
        });
        return res.body;
    }
    catch (error) {
        throw (0, errors_1.handleError)(error);
    }
}
exports.blocksNext = blocksNext;
/**
 * Obtains list of blocks preceding a specific block.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1%7Bhash_or_number%7D~previous/get | API docs for Listing of previous blocks}
 *
 * @param hashOrNumber - Hash or number of the requested block
 * @param pagination - Optional, Pagination options
 * @returns List of blocks preceding a specific block
 *
 */
async function blocksPrevious(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    try {
        const res = await this.instance(`blocks/${hashOrNumber}/previous`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
            },
        });
        return res.body;
    }
    catch (error) {
        throw (0, errors_1.handleError)(error);
    }
}
exports.blocksPrevious = blocksPrevious;
/**
 * Obtains transactions within the specific block.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1%7Bhash_or_number%7D~1txs/get | API docs for Block transactions}
 *
 * @param hashOrNumber - Hash or number of the requested block
 * @param pagination - Optional, Pagination options
 * @returns Transactions within the specific block
 *
 */
async function blocksTxs(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    try {
        const res = await this.instance(`blocks/${hashOrNumber}/txs`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        });
        return res.body;
    }
    catch (error) {
        throw (0, errors_1.handleError)(error);
    }
}
exports.blocksTxs = blocksTxs;
/**
 * Obtains all transactions within the specific block.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1%7Bhash_or_number%7D~1txs/get | API docs for Block transactions}
 * @remarks
 * Variant of `blocksTxs` method for fetching all pages with built-in requests batching
 *
 * @param hashOrNumber - Hash or number of the requested block
 * @param allMethodOptions - Optional, Options for request batching
 * @returns All transactions within the specific block
 *
 */
async function blocksTxsAll(hashOrNumber, allMethodOptions) {
    return (0, utils_1.paginateMethod)(pagination => this.blocksTxs(hashOrNumber, pagination), allMethodOptions);
}
exports.blocksTxsAll = blocksTxsAll;
/**
 * Obtains list of addresses affected in the specified block with additional information.
 * @remarks
 * Sorted by the bech32 address, in ascending order.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1%7Bhash_or_number%7D~1addresses/get | API docs for Addresses affected in a specific block}
 *
 * @param hashOrNumber - Hash or number of the requested block
 * @param pagination - Optional, Pagination options
 * @returns List of addresses affected in the specified block
 *
 */
async function blocksAddresses(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    try {
        const res = await this.instance(`blocks/${hashOrNumber}/addresses`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                // order: paginationOptions.order, // no ordering on /blocks/{hash}/addresses
            },
        });
        return res.body;
    }
    catch (error) {
        throw (0, errors_1.handleError)(error);
    }
}
exports.blocksAddresses = blocksAddresses;
/**
 * Obtains list of addresses affected in the specified block with additional information.
 * @see {@link https://docs.blockfrost.io/#tag/Cardano-Blocks/paths/~1blocks~1%7Bhash_or_number%7D~1addresses/get | API docs for Addresses affected in a specific block}
 * @remarks
 * Sorted by the bech32 address, in ascending order.
 * @remarks
 * Variant of `blocksAddresses` method for fetching all pages with built-in requests batching
 *
 * @param hashOrNumber - Hash or number of the requested block
 * @param allMethodOptions - Optional, Options for request batching
 * @returns List of addresses affected in the specified block
 *
 */
async function blocksAddressesAll(hashOrNumber, allMethodOptions) {
    return (0, utils_1.paginateMethod)(pagination => this.blocksAddresses(hashOrNumber, pagination), allMethodOptions);
}
exports.blocksAddressesAll = blocksAddressesAll;
