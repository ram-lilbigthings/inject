"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleError = exports.isBlockfrostErrorResponse = exports.BlockfrostClientError = exports.BlockfrostServerError = exports.SignatureVerificationError = void 0;
const got_1 = require("got");
class SignatureVerificationError extends Error {
    constructor(message, detail) {
        super(message);
        this.name = 'SignatureVerificationError';
        this.message = message;
        this.detail = detail;
        Object.setPrototypeOf(this, SignatureVerificationError.prototype);
    }
}
exports.SignatureVerificationError = SignatureVerificationError;
class BlockfrostServerError extends Error {
    constructor(error) {
        super(error.message);
        this.name = 'BlockfrostServerError';
        this.status_code = error.status_code;
        this.message = error.message;
        this.error = error.error;
        this.url = error.url;
        this.body = error.body;
        Object.setPrototypeOf(this, BlockfrostServerError.prototype);
    }
}
exports.BlockfrostServerError = BlockfrostServerError;
class BlockfrostClientError extends Error {
    constructor(error) {
        super(error.message);
        this.name = 'BlockfrostClientError';
        this.code = error.code;
        this.message = error.message;
        this.url = error.url;
        Object.setPrototypeOf(this, BlockfrostClientError.prototype);
    }
}
exports.BlockfrostClientError = BlockfrostClientError;
const hasProp = (
// eslint-disable-next-line @typescript-eslint/ban-types
data, prop) => {
    return prop in data;
};
const isBlockfrostErrorResponse = (data) => {
    // type guard for narrowing response body to an error object that should be returned by Blockfrost API
    return (typeof data === 'object' &&
        data !== null &&
        hasProp(data, 'status_code') &&
        hasProp(data, 'message') &&
        hasProp(data, 'error'));
};
exports.isBlockfrostErrorResponse = isBlockfrostErrorResponse;
const handleError = (error) => {
    if (error instanceof got_1.HTTPError) {
        let errorInstance;
        const url = error.request.requestUrl;
        const responseBody = error.response.body;
        if ((0, exports.isBlockfrostErrorResponse)(responseBody)) {
            errorInstance = new BlockfrostServerError({ ...responseBody, url });
        }
        else {
            // response.body may contain html output (eg. errors returned by nginx)
            const { statusCode } = error.response;
            const statusText = error.response.statusMessage ?? error.message;
            errorInstance = new BlockfrostServerError({
                status_code: statusCode,
                message: `${statusCode}: ${statusText}`,
                error: statusText,
                url,
                // Sometimes original body can be helpful so let's forward it
                // Eg. communicating directly with Cardano Submit API which returns 400 with the error from cardano-node in the body of the request)
                body: error.response.body ? error.response.body : undefined,
            });
        }
        // remove undefined body prop so it doesn't pollute string representation of the error
        if (errorInstance.body === undefined) {
            delete errorInstance.body;
        }
        return errorInstance;
    }
    // system errors such as -3008 ENOTFOUND and various got errors like ReadError, CacheError, MaxRedirectsError, TimeoutError,...
    // https://github.com/sindresorhus/got/blob/main/documentation/8-errors.md
    return new BlockfrostClientError({
        code: error.code ?? 'ERR_GOT_REQUEST_ERROR',
        message: error.message,
        url: error.request?.requestUrl,
    });
};
exports.handleError = handleError;
