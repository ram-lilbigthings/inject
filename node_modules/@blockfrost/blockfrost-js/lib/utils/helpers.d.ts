import { ParseAssetResult } from '../types/utils';
import { WebhookEvent } from '../types/webhook';
/**
 * Derives an address with derivation path `m/1852'/1815'/account'/role/addressIndex`
 * If role is set to `2` then it returns a stake address (`m/1852'/1815'/account'/2/addressIndex`)
 *
 * @param accountPublicKey - hex-encoded account public key
 * @param role - role within derivation path `m/1852'/1815'/account'/role/addressIndex`
 * @param addressIndex - address index within derivation path `m/1852'/1815'/account'/role/addressIndex`
 * @param isTestnet - Whether to derive testnet address
 * @param isByron - Whether to derive Byron address (Optional, default false)
 * @returns Object with bech32 address and corresponding partial derivation path `{address: string, path: [role, addressIndex]}`
 * @example
 *
 * ```ts
 * const Blockfrost = require('@blockfrost/blockfrost-js');
 * const res = Blockfrost.deriveAddress(
 * '7ec9738746cb4708df52a455b43aa3fdee8955abaf37f68ffc79bb84fbf9e1b39d77e2deb9749faf890ff8326d350ed3fd0e4aa271b35cad063692af87102152',
 *  0,
 *  1,
 *  false,
 * );
 * console.log(res);
 * // {
 * //   address: 'addr1qy535472n2ctu3x55v03zmm9jnz54grqu3sueap9pnk4xys49ucjdfty5p5qlw5qe28v9k988stffc2g0hx2xx86a2dq5u58qk',
 * //   path: [0, 1],
 * // }
 * ```
 * */
export declare const deriveAddress: (accountPublicKey: string, role: number, addressIndex: number, isTestnet: boolean, isByron?: boolean) => {
    address: string;
    path: [number, number];
};
export declare const hexToString: (input: string) => string;
/**
 * Calculates asset fingerprint.
 *
 * @param policyId - Policy Id
 * @param assetName - hex-encoded asset name
 * @returns Asset fingerprint for the given policy ID and asset name.
 * @example
 *
 * ```ts
 * const Blockfrost = require('@blockfrost/blockfrost-js');
 * const res = Blockfrost.getFingerprint(
 *  '00000002df633853f6a47465c9496721d2d5b1291b8398016c0e87ae',
 *  '6e7574636f696e',
 * );
 * console.log(res);
 * // 'asset12h3p5l3nd5y26lr22am7y7ga3vxghkhf57zkhd'
 * ```
 * */
export declare const getFingerprint: (policyId: string, assetName?: string) => string;
/**
 * Parses asset hex and returns its policy ID, asset name and fingerprint.
 *
 * @param hex - hex-encoded asset
 * @returns Object containing `policyId`, `assetName`, `assetNameHex` and `fingerprint`.
 * @example
 *
 * ```ts
 * const Blockfrost = require('@blockfrost/blockfrost-js');
 * const res = Blockfrost.parseAsset('00000002df633853f6a47465c9496721d2d5b1291b8398016c0e87ae6e7574636f696e');
 * console.log(res);
 * // {
 * //   "assetName": 'nutcoin',
 * //   "assetNameHex": '6e7574636f696e',
 * //   "fingerprint": 'asset12h3p5l3nd5y26lr22am7y7ga3vxghkhf57zkhd',
 * //   "policyId": '00000002df633853f6a47465c9496721d2d5b1291b8398016c0e87ae',
 * // }
 * ```
 * */
export declare const parseAsset: (hex: string) => ParseAssetResult;
/**
 * Verifies webhook signature
 * @remarks
 * Webhooks enable Blockfrost to push real-time notifications to your application. In order to prevent malicious actor from pretending to be Blockfrost every webhook request is signed. The signature is included in a request's `Blockfrost-Signature` header. This allows you to verify that the events were sent by Blockfrost, not by a third party.
 *
 * To learn more about Secure Webhooks, see [Secure Webhooks Docs](https://blockfrost.dev/docs/start-building/webhooks/).
 * For full example project, see [webhook-basic example](https://github.com/blockfrost/blockfrost-js-examples/tree/master/examples/webhook-basic).
 *
 * @param webhookPayload - Buffer or stringified payload of the webhook request.
 * @param signatureHeader - Buffer or stringified Blockfrost-Signature header.
 * @param secret - Auth token for the webhook.
 * @param timestampToleranceSeconds - Time tolerance affecting signature validity. Optional, by default signatures older than 600s are considered invalid.
 * @returns `true` for the valid signature, otherwise throws `SignatureVerificationError`
 *
 * @throws {@link SignatureVerificationError}
 * Thrown if the signature is not valid. For easier debugging the SignatureVerificationError has additional detail object with 2 properties - header and request_body.
 * */
export declare const verifyWebhookSignature: (webhookPayload: unknown, signatureHeader: string | string[], secret: string, timestampToleranceSeconds?: number) => WebhookEvent;
